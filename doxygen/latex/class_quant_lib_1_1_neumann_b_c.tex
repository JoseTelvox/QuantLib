\doxysection{Quant\+Lib\+::Neumann\+BC Class Reference}
\hypertarget{class_quant_lib_1_1_neumann_b_c}{}\label{class_quant_lib_1_1_neumann_b_c}\index{QuantLib::NeumannBC@{QuantLib::NeumannBC}}


Neumann boundary condition (i.\+e., constant derivative)  




{\ttfamily \#include $<$boundarycondition.\+hpp$>$}

Inheritance diagram for Quant\+Lib\+::Neumann\+BC\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_quant_lib_1_1_neumann_b_c}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{class_quant_lib_1_1_neumann_b_c_a5e0c847cd8ece536605c0735d2112a14}\label{class_quant_lib_1_1_neumann_b_c_a5e0c847cd8ece536605c0735d2112a14} 
{\bfseries Neumann\+BC} (\mbox{\hyperlink{namespace_quant_lib_a372ac5c1a422a6b276fe0552d4d83f50}{Real}} value, \mbox{\hyperlink{class_quant_lib_1_1_boundary_condition}{Side}} side)
\item 
void \mbox{\hyperlink{class_quant_lib_1_1_neumann_b_c_aee8d2b79d26946bae0fff30bf6c9ae10}{apply\+Before\+Applying}} (\mbox{\hyperlink{class_quant_lib_1_1_tridiagonal_operator}{Tridiagonal\+Operator}} \&) const override
\item 
void \mbox{\hyperlink{class_quant_lib_1_1_neumann_b_c_a46574aeb587edd7da26c8b8697e7e027}{apply\+After\+Applying}} (\mbox{\hyperlink{class_quant_lib_1_1_array}{Array}} \&) const override
\item 
void \mbox{\hyperlink{class_quant_lib_1_1_neumann_b_c_a0b65a0a6818fb1ddcd4cd1dc85751777}{apply\+Before\+Solving}} (\mbox{\hyperlink{class_quant_lib_1_1_tridiagonal_operator}{Tridiagonal\+Operator}} \&, \mbox{\hyperlink{class_quant_lib_1_1_array}{Array}} \&rhs) const override
\item 
void \mbox{\hyperlink{class_quant_lib_1_1_neumann_b_c_a21148dd45b0e910f60319966ef539ccb}{apply\+After\+Solving}} (\mbox{\hyperlink{class_quant_lib_1_1_array}{Array}} \&) const override
\item 
void \mbox{\hyperlink{class_quant_lib_1_1_neumann_b_c_a959a84d01a7c46ad5ed042278d85f5c8}{set\+Time}} (\mbox{\hyperlink{namespace_quant_lib_a4f78b18a4dd1a979eb78b4e1e8ac1503}{Time}}) override
\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Public Types inherited from \mbox{\hyperlink{class_quant_lib_1_1_boundary_condition}{Quant\+Lib\+::\+Boundary\+Condition$<$ Tridiagonal\+Operator $>$}}}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{class_quant_lib_1_1_boundary_condition_ab685ab8e5ea909d20f659fab031a3dcb}{Side}} 
\item 
typedef \mbox{\hyperlink{class_quant_lib_1_1_tridiagonal_operator}{Tridiagonal\+Operator}} {\bfseries operator\+\_\+type}
\item 
typedef \mbox{\hyperlink{class_quant_lib_1_1_array}{Tridiagonal\+Operator\+::array\+\_\+type}} {\bfseries array\+\_\+type}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Neumann boundary condition (i.\+e., constant derivative) 

\begin{DoxyWarning}{Warning}
The value passed must not be the value of the derivative. Instead, it must be comprehensive of the grid step between the first two points--i.\+e., it must be the difference between f\mbox{[}0\mbox{]} and f\mbox{[}1\mbox{]}. 
\end{DoxyWarning}
\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{todo__todo000053}{Todo}}]generalize to time-\/dependent conditions.\end{DoxyRefDesc}


\doxysubsection{Member Function Documentation}
\Hypertarget{class_quant_lib_1_1_neumann_b_c_a46574aeb587edd7da26c8b8697e7e027}\index{QuantLib::NeumannBC@{QuantLib::NeumannBC}!applyAfterApplying@{applyAfterApplying}}
\index{applyAfterApplying@{applyAfterApplying}!QuantLib::NeumannBC@{QuantLib::NeumannBC}}
\doxysubsubsection{\texorpdfstring{applyAfterApplying()}{applyAfterApplying()}}
{\footnotesize\ttfamily \label{class_quant_lib_1_1_neumann_b_c_a46574aeb587edd7da26c8b8697e7e027} 
void Quant\+Lib\+::\+Neumann\+BC\+::apply\+After\+Applying (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_quant_lib_1_1_array}{Array}} \&}]{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

This method modifies an array $ u $ so that it satisfies the given condition. 

Implements \mbox{\hyperlink{class_quant_lib_1_1_boundary_condition_af885136ffc2b670924fd6579b6fb360e}{Quant\+Lib\+::\+Boundary\+Condition$<$ Tridiagonal\+Operator $>$}}.

\Hypertarget{class_quant_lib_1_1_neumann_b_c_a21148dd45b0e910f60319966ef539ccb}\index{QuantLib::NeumannBC@{QuantLib::NeumannBC}!applyAfterSolving@{applyAfterSolving}}
\index{applyAfterSolving@{applyAfterSolving}!QuantLib::NeumannBC@{QuantLib::NeumannBC}}
\doxysubsubsection{\texorpdfstring{applyAfterSolving()}{applyAfterSolving()}}
{\footnotesize\ttfamily \label{class_quant_lib_1_1_neumann_b_c_a21148dd45b0e910f60319966ef539ccb} 
void Quant\+Lib\+::\+Neumann\+BC\+::apply\+After\+Solving (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_quant_lib_1_1_array}{Array}} \&}]{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

This method modifies an array $ u $ so that it satisfies the given condition. 

Implements \mbox{\hyperlink{class_quant_lib_1_1_boundary_condition_ab63c69a9c991dcb908d399c2e6304970}{Quant\+Lib\+::\+Boundary\+Condition$<$ Tridiagonal\+Operator $>$}}.

\Hypertarget{class_quant_lib_1_1_neumann_b_c_aee8d2b79d26946bae0fff30bf6c9ae10}\index{QuantLib::NeumannBC@{QuantLib::NeumannBC}!applyBeforeApplying@{applyBeforeApplying}}
\index{applyBeforeApplying@{applyBeforeApplying}!QuantLib::NeumannBC@{QuantLib::NeumannBC}}
\doxysubsubsection{\texorpdfstring{applyBeforeApplying()}{applyBeforeApplying()}}
{\footnotesize\ttfamily \label{class_quant_lib_1_1_neumann_b_c_aee8d2b79d26946bae0fff30bf6c9ae10} 
void Quant\+Lib\+::\+Neumann\+BC\+::apply\+Before\+Applying (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_quant_lib_1_1_tridiagonal_operator}{Tridiagonal\+Operator}} \&}]{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

This method modifies an operator $ L $ before it is applied to an array $ u $ so that $ v = Lu $ will satisfy the given condition. 

Implements \mbox{\hyperlink{class_quant_lib_1_1_boundary_condition_a090e687cdd747c7131aa95d564a26cff}{Quant\+Lib\+::\+Boundary\+Condition$<$ Tridiagonal\+Operator $>$}}.

\Hypertarget{class_quant_lib_1_1_neumann_b_c_a0b65a0a6818fb1ddcd4cd1dc85751777}\index{QuantLib::NeumannBC@{QuantLib::NeumannBC}!applyBeforeSolving@{applyBeforeSolving}}
\index{applyBeforeSolving@{applyBeforeSolving}!QuantLib::NeumannBC@{QuantLib::NeumannBC}}
\doxysubsubsection{\texorpdfstring{applyBeforeSolving()}{applyBeforeSolving()}}
{\footnotesize\ttfamily \label{class_quant_lib_1_1_neumann_b_c_a0b65a0a6818fb1ddcd4cd1dc85751777} 
void Quant\+Lib\+::\+Neumann\+BC\+::apply\+Before\+Solving (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_quant_lib_1_1_tridiagonal_operator}{Tridiagonal\+Operator}} \&}]{}{, }\item[{\mbox{\hyperlink{class_quant_lib_1_1_array}{Array}} \&}]{rhs}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

This method modifies an operator $ L $ before the linear system $ Lu\textnormal{\textquotesingle} = u $ is solved so that $ u\textnormal{\textquotesingle} $ will satisfy the given condition. 

Implements \mbox{\hyperlink{class_quant_lib_1_1_boundary_condition_a1d5d7879dbecac59bef8df64e3b10fa7}{Quant\+Lib\+::\+Boundary\+Condition$<$ Tridiagonal\+Operator $>$}}.

\Hypertarget{class_quant_lib_1_1_neumann_b_c_a959a84d01a7c46ad5ed042278d85f5c8}\index{QuantLib::NeumannBC@{QuantLib::NeumannBC}!setTime@{setTime}}
\index{setTime@{setTime}!QuantLib::NeumannBC@{QuantLib::NeumannBC}}
\doxysubsubsection{\texorpdfstring{setTime()}{setTime()}}
{\footnotesize\ttfamily \label{class_quant_lib_1_1_neumann_b_c_a959a84d01a7c46ad5ed042278d85f5c8} 
void Quant\+Lib\+::\+Neumann\+BC\+::set\+Time (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_quant_lib_a4f78b18a4dd1a979eb78b4e1e8ac1503}{Time}}}]{t}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}

This method sets the current time for time-\/dependent boundary conditions. 

Implements \mbox{\hyperlink{class_quant_lib_1_1_boundary_condition_a391ec4058846a3d2f0cd49324c3de790}{Quant\+Lib\+::\+Boundary\+Condition$<$ Tridiagonal\+Operator $>$}}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
ql/methods/finitedifferences/\mbox{\hyperlink{boundarycondition_8hpp}{boundarycondition.\+hpp}}\item 
ql/methods/finitedifferences/boundarycondition.\+cpp\end{DoxyCompactItemize}
