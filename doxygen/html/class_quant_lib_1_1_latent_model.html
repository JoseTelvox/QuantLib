<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quant Lib: QuantLib::LatentModel&lt; copulaPolicyImpl &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Quant Lib
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_quant_lib_1_1_latent_model.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="class_quant_lib_1_1_latent_model-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">QuantLib::LatentModel&lt; copulaPolicyImpl &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Generic multifactor latent variable model.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="latentmodel_8hpp_source.html">latentmodel.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for QuantLib::LatentModel&lt; copulaPolicyImpl &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_quant_lib_1_1_latent_model.png" usemap="#QuantLib::LatentModel_3C_20copulaPolicyImpl_20_3E_map" alt=""/>
  <map id="QuantLib::LatentModel_3C_20copulaPolicyImpl_20_3E_map" name="QuantLib::LatentModel_3C_20copulaPolicyImpl_20_3E_map">
<area href="class_quant_lib_1_1_observer.html" title="Object that gets notified when a given observable changes." alt="QuantLib::Observer" shape="rect" coords="0,0,324,24"/>
<area href="class_quant_lib_1_1_observable.html" title="Object that notifies its changes to a set of observers." alt="QuantLib::Observable" shape="rect" coords="334,0,658,24"/>
<area href="class_quant_lib_1_1_default_latent_model.html" alt="QuantLib::DefaultLatentModel&lt; TCopulaPolicy &gt;" shape="rect" coords="0,112,324,136"/>
<area href="class_quant_lib_1_1_spot_recovery_latent_model.html" alt="QuantLib::SpotRecoveryLatentModel&lt; TCopulaPolicy &gt;" shape="rect" coords="334,112,658,136"/>
<area href="class_quant_lib_1_1_constant_loss_latentmodel.html" alt="QuantLib::ConstantLossLatentmodel&lt; TCopulaPolicy &gt;" shape="rect" coords="0,168,324,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_latent_model_1_1_factor_sampler.html">FactorSampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_latent_model_1_1_integration_factory.html">IntegrationFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Latent model direct integration facility.</div></td></tr>
<tr class="memitem:a25404a7f39fe1422f6e4dd1fb9b67115" id="r_a25404a7f39fe1422f6e4dd1fb9b67115"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25404a7f39fe1422f6e4dd1fb9b67115">update</a> () override</td></tr>
<tr class="separator:a25404a7f39fe1422f6e4dd1fb9b67115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Latent model random factor number generator facility.</div></td></tr>
<tr class="memitem:a1dedcee7cecd341a0ed6131577b2f48e" id="r_a1dedcee7cecd341a0ed6131577b2f48e"><td class="memItemLeft" align="right" valign="top"><a id="a1dedcee7cecd341a0ed6131577b2f48e" name="a1dedcee7cecd341a0ed6131577b2f48e"></a>
<a class="el" href="namespace_quant_lib.html#af4cc4ef40b52c17cc455ead2a97aedb3">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:a1dedcee7cecd341a0ed6131577b2f48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad410d410b17c524efa114598a0455936" id="r_ad410d410b17c524efa114598a0455936"><td class="memItemLeft" align="right" valign="top"><a id="ad410d410b17c524efa114598a0455936" name="ad410d410b17c524efa114598a0455936"></a>
<a class="el" href="namespace_quant_lib.html#af4cc4ef40b52c17cc455ead2a97aedb3">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><b>numFactors</b> () const</td></tr>
<tr class="memdesc:ad410d410b17c524efa114598a0455936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of systemic factors. <br /></td></tr>
<tr class="separator:ad410d410b17c524efa114598a0455936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752c04c15550a49537c7eb0557bd6b16" id="r_a752c04c15550a49537c7eb0557bd6b16"><td class="memItemLeft" align="right" valign="top"><a id="a752c04c15550a49537c7eb0557bd6b16" name="a752c04c15550a49537c7eb0557bd6b16"></a>
<a class="el" href="namespace_quant_lib.html#af4cc4ef40b52c17cc455ead2a97aedb3">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><b>numTotalFactors</b> () const</td></tr>
<tr class="memdesc:a752c04c15550a49537c7eb0557bd6b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of total free random factors; systemic and idiosyncratic. <br /></td></tr>
<tr class="separator:a752c04c15550a49537c7eb0557bd6b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2423b7437ca2ba9796e153bd9b9df050" id="r_a2423b7437ca2ba9796e153bd9b9df050"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2423b7437ca2ba9796e153bd9b9df050">LatentModel</a> (const std::vector&lt; std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt; &gt; &amp;factorsWeights, const typename copulaType::initTraits &amp;ini=typename copulaType::initTraits())</td></tr>
<tr class="separator:a2423b7437ca2ba9796e153bd9b9df050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250ac646a6be88e253dc37c2620de9dd" id="r_a250ac646a6be88e253dc37c2620de9dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a250ac646a6be88e253dc37c2620de9dd">LatentModel</a> (const std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt; &amp;factorsWeight, const typename copulaType::initTraits &amp;ini=typename copulaType::initTraits())</td></tr>
<tr class="separator:a250ac646a6be88e253dc37c2620de9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762ae56003287bdd2995e5a46a8c9f57" id="r_a762ae56003287bdd2995e5a46a8c9f57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a762ae56003287bdd2995e5a46a8c9f57">LatentModel</a> (<a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> correlSqr, <a class="el" href="namespace_quant_lib.html#af4cc4ef40b52c17cc455ead2a97aedb3">Size</a> nVariables, const typename copulaType::initTraits &amp;ini=typename copulaType::initTraits())</td></tr>
<tr class="separator:a762ae56003287bdd2995e5a46a8c9f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4200b7490c6d6690d2ec1df95d4862ba" id="r_a4200b7490c6d6690d2ec1df95d4862ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4200b7490c6d6690d2ec1df95d4862ba">LatentModel</a> (const <a class="el" href="class_quant_lib_1_1_handle.html">Handle</a>&lt; <a class="el" href="class_quant_lib_1_1_quote.html">Quote</a> &gt; &amp;singleFactorCorrel, <a class="el" href="namespace_quant_lib.html#af4cc4ef40b52c17cc455ead2a97aedb3">Size</a> nVariables, const typename copulaType::initTraits &amp;ini=typename copulaType::initTraits())</td></tr>
<tr class="separator:a4200b7490c6d6690d2ec1df95d4862ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9058f44d45963e20631cf813f500ed50" id="r_a9058f44d45963e20631cf813f500ed50"><td class="memItemLeft" align="right" valign="top"><a id="a9058f44d45963e20631cf813f500ed50" name="a9058f44d45963e20631cf813f500ed50"></a>
const std::vector&lt; std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>factorWeights</b> () const</td></tr>
<tr class="memdesc:a9058f44d45963e20631cf813f500ed50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides values of the factors <picture><source srcset="form_147_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ a_{i,k} $" src="form_147.png"/></picture>. <br /></td></tr>
<tr class="separator:a9058f44d45963e20631cf813f500ed50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad630746a257d3e970ecf83cd47878cd3" id="r_ad630746a257d3e970ecf83cd47878cd3"><td class="memItemLeft" align="right" valign="top"><a id="ad630746a257d3e970ecf83cd47878cd3" name="ad630746a257d3e970ecf83cd47878cd3"></a>
const std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>idiosyncFctrs</b> () const</td></tr>
<tr class="memdesc:ad630746a257d3e970ecf83cd47878cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides values of the normalized idiosyncratic factors <picture><source srcset="form_87_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ Z_i $" src="form_87.png"/></picture>. <br /></td></tr>
<tr class="separator:ad630746a257d3e970ecf83cd47878cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3034be325054187dfafbd5f7ef1890" id="r_a9d3034be325054187dfafbd5f7ef1890"><td class="memItemLeft" align="right" valign="top"><a id="a9d3034be325054187dfafbd5f7ef1890" name="a9d3034be325054187dfafbd5f7ef1890"></a>
<a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>latentVariableCorrel</b> (<a class="el" href="namespace_quant_lib.html#af4cc4ef40b52c17cc455ead2a97aedb3">Size</a> iVar1, <a class="el" href="namespace_quant_lib.html#af4cc4ef40b52c17cc455ead2a97aedb3">Size</a> iVar2) const</td></tr>
<tr class="memdesc:a9d3034be325054187dfafbd5f7ef1890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Latent variable correlations: <br /></td></tr>
<tr class="separator:a9d3034be325054187dfafbd5f7ef1890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_quant_lib_1_1_observer"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_quant_lib_1_1_observer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_quant_lib_1_1_observer.html">QuantLib::Observer</a></td></tr>
<tr class="memitem:ae6e892e237db5ffe7acbef54360ef0e3 inherit pub_methods_class_quant_lib_1_1_observer" id="r_ae6e892e237db5ffe7acbef54360ef0e3"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Observer</b> (const <a class="el" href="class_quant_lib_1_1_observer.html">Observer</a> &amp;)</td></tr>
<tr class="separator:ae6e892e237db5ffe7acbef54360ef0e3 inherit pub_methods_class_quant_lib_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ad1a8bfb71e32b2916b370f3f9392c inherit pub_methods_class_quant_lib_1_1_observer" id="r_a40ad1a8bfb71e32b2916b370f3f9392c"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="class_quant_lib_1_1_observer.html">Observer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_quant_lib_1_1_observer.html">Observer</a> &amp;)</td></tr>
<tr class="separator:a40ad1a8bfb71e32b2916b370f3f9392c inherit pub_methods_class_quant_lib_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312bbe4a5386f10a1584f3477b3c2709 inherit pub_methods_class_quant_lib_1_1_observer" id="r_a312bbe4a5386f10a1584f3477b3c2709"><td class="memItemLeft" align="right" valign="top">
std::pair&lt; iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>registerWith</b> (const ext::shared_ptr&lt; <a class="el" href="class_quant_lib_1_1_observable.html">Observable</a> &gt; &amp;)</td></tr>
<tr class="separator:a312bbe4a5386f10a1584f3477b3c2709 inherit pub_methods_class_quant_lib_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338928c4fe626f9ccf0b98ceb318853a inherit pub_methods_class_quant_lib_1_1_observer" id="r_a338928c4fe626f9ccf0b98ceb318853a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_observer.html#a338928c4fe626f9ccf0b98ceb318853a">registerWithObservables</a> (const ext::shared_ptr&lt; <a class="el" href="class_quant_lib_1_1_observer.html">Observer</a> &gt; &amp;)</td></tr>
<tr class="separator:a338928c4fe626f9ccf0b98ceb318853a inherit pub_methods_class_quant_lib_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297d13afa77b0e7e6deae3bab777180f inherit pub_methods_class_quant_lib_1_1_observer" id="r_a297d13afa77b0e7e6deae3bab777180f"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespace_quant_lib.html#af4cc4ef40b52c17cc455ead2a97aedb3">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><b>unregisterWith</b> (const ext::shared_ptr&lt; <a class="el" href="class_quant_lib_1_1_observable.html">Observable</a> &gt; &amp;)</td></tr>
<tr class="separator:a297d13afa77b0e7e6deae3bab777180f inherit pub_methods_class_quant_lib_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88925691aba7e7d96cc5188e94361ea inherit pub_methods_class_quant_lib_1_1_observer" id="r_ab88925691aba7e7d96cc5188e94361ea"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>unregisterWithAll</b> ()</td></tr>
<tr class="separator:ab88925691aba7e7d96cc5188e94361ea inherit pub_methods_class_quant_lib_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbf794db3e7d5cfdea2cd517a195183 inherit pub_methods_class_quant_lib_1_1_observer" id="r_acfbf794db3e7d5cfdea2cd517a195183"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_observer.html#acfbf794db3e7d5cfdea2cd517a195183">deepUpdate</a> ()</td></tr>
<tr class="separator:acfbf794db3e7d5cfdea2cd517a195183 inherit pub_methods_class_quant_lib_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_quant_lib_1_1_observable"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_quant_lib_1_1_observable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_quant_lib_1_1_observable.html">QuantLib::Observable</a></td></tr>
<tr class="memitem:a942cf6a572bd95341433a6772c70cb29 inherit pub_methods_class_quant_lib_1_1_observable" id="r_a942cf6a572bd95341433a6772c70cb29"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Observable</b> (const <a class="el" href="class_quant_lib_1_1_observable.html">Observable</a> &amp;)</td></tr>
<tr class="separator:a942cf6a572bd95341433a6772c70cb29 inherit pub_methods_class_quant_lib_1_1_observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e086da62f05b4bc5eafa698ef6fbc3 inherit pub_methods_class_quant_lib_1_1_observable" id="r_ad1e086da62f05b4bc5eafa698ef6fbc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_quant_lib_1_1_observable.html">Observable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_observable.html#ad1e086da62f05b4bc5eafa698ef6fbc3">operator=</a> (const <a class="el" href="class_quant_lib_1_1_observable.html">Observable</a> &amp;)</td></tr>
<tr class="separator:ad1e086da62f05b4bc5eafa698ef6fbc3 inherit pub_methods_class_quant_lib_1_1_observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c35885ef344665ecdfac9b9f3a59c0e inherit pub_methods_class_quant_lib_1_1_observable" id="r_a6c35885ef344665ecdfac9b9f3a59c0e"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Observable</b> (<a class="el" href="class_quant_lib_1_1_observable.html">Observable</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a6c35885ef344665ecdfac9b9f3a59c0e inherit pub_methods_class_quant_lib_1_1_observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45941c65068ab4c8d69a7d1a72beeb7 inherit pub_methods_class_quant_lib_1_1_observable" id="r_ab45941c65068ab4c8d69a7d1a72beeb7"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="class_quant_lib_1_1_observable.html">Observable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_quant_lib_1_1_observable.html">Observable</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ab45941c65068ab4c8d69a7d1a72beeb7 inherit pub_methods_class_quant_lib_1_1_observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb67478418efdb94382ac9d7ae904b94 inherit pub_methods_class_quant_lib_1_1_observable" id="r_afb67478418efdb94382ac9d7ae904b94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_observable.html#afb67478418efdb94382ac9d7ae904b94">notifyObservers</a> ()</td></tr>
<tr class="separator:afb67478418efdb94382ac9d7ae904b94 inherit pub_methods_class_quant_lib_1_1_observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Copula interface.</h2></td></tr>
<tr class="memitem:aad1fd370b3f36c3cf24b661d189fed01" id="r_aad1fd370b3f36c3cf24b661d189fed01"><td class="memItemLeft" align="right" valign="top"><a id="aad1fd370b3f36c3cf24b661d189fed01" name="aad1fd370b3f36c3cf24b661d189fed01"></a>
typedef copulaPolicyImpl&#160;</td><td class="memItemRight" valign="bottom"><b>copulaType</b></td></tr>
<tr class="separator:aad1fd370b3f36c3cf24b661d189fed01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af159333d575c0b252de3c71371919dc2" id="r_af159333d575c0b252de3c71371919dc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_quant_lib.html#ac41728dd3be3e1869bbb9aec06a89d60">Probability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af159333d575c0b252de3c71371919dc2">cumulativeY</a> (<a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> val, <a class="el" href="namespace_quant_lib.html#af4cc4ef40b52c17cc455ead2a97aedb3">Size</a> iVariable) const</td></tr>
<tr class="separator:af159333d575c0b252de3c71371919dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64724a9ecdc4cb7dadd555b019da10b" id="r_ae64724a9ecdc4cb7dadd555b019da10b"><td class="memItemLeft" align="right" valign="top"><a id="ae64724a9ecdc4cb7dadd555b019da10b" name="ae64724a9ecdc4cb7dadd555b019da10b"></a>
<a class="el" href="namespace_quant_lib.html#ac41728dd3be3e1869bbb9aec06a89d60">Probability</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cumulativeZ</b> (<a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> z) const</td></tr>
<tr class="memdesc:ae64724a9ecdc4cb7dadd555b019da10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative distribution of Z, the idiosyncratic/error factors. <br /></td></tr>
<tr class="separator:ae64724a9ecdc4cb7dadd555b019da10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9711849d61e8bc79608424661ac9dde2" id="r_a9711849d61e8bc79608424661ac9dde2"><td class="memItemLeft" align="right" valign="top"><a id="a9711849d61e8bc79608424661ac9dde2" name="a9711849d61e8bc79608424661ac9dde2"></a>
<a class="el" href="namespace_quant_lib.html#ac41728dd3be3e1869bbb9aec06a89d60">Probability</a>&#160;</td><td class="memItemRight" valign="bottom"><b>density</b> (const std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt; &amp;m) const</td></tr>
<tr class="memdesc:a9711849d61e8bc79608424661ac9dde2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Density function of M, the market/systemic factors. <br /></td></tr>
<tr class="separator:a9711849d61e8bc79608424661ac9dde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f1e843503876609d1cb14ac9b26c8e" id="r_a10f1e843503876609d1cb14ac9b26c8e"><td class="memItemLeft" align="right" valign="top"><a id="a10f1e843503876609d1cb14ac9b26c8e" name="a10f1e843503876609d1cb14ac9b26c8e"></a>
<a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>inverseCumulativeDensity</b> (<a class="el" href="namespace_quant_lib.html#ac41728dd3be3e1869bbb9aec06a89d60">Probability</a> p, <a class="el" href="namespace_quant_lib.html#af4cc4ef40b52c17cc455ead2a97aedb3">Size</a> iFactor) const</td></tr>
<tr class="memdesc:a10f1e843503876609d1cb14ac9b26c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse cumulative distribution of the systemic factor iFactor. <br /></td></tr>
<tr class="separator:a10f1e843503876609d1cb14ac9b26c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4c7a3b52e2a50a88b3a2e67cc1109b" id="r_a8f4c7a3b52e2a50a88b3a2e67cc1109b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f4c7a3b52e2a50a88b3a2e67cc1109b">inverseCumulativeY</a> (<a class="el" href="namespace_quant_lib.html#ac41728dd3be3e1869bbb9aec06a89d60">Probability</a> p, <a class="el" href="namespace_quant_lib.html#af4cc4ef40b52c17cc455ead2a97aedb3">Size</a> iVariable) const</td></tr>
<tr class="separator:a8f4c7a3b52e2a50a88b3a2e67cc1109b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28355f257003546d33fda003452c820e" id="r_a28355f257003546d33fda003452c820e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28355f257003546d33fda003452c820e">inverseCumulativeZ</a> (<a class="el" href="namespace_quant_lib.html#ac41728dd3be3e1869bbb9aec06a89d60">Probability</a> p) const</td></tr>
<tr class="separator:a28355f257003546d33fda003452c820e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b6963ac7d92d55caade265c40af9e4" id="r_a77b6963ac7d92d55caade265c40af9e4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77b6963ac7d92d55caade265c40af9e4">allFactorCumulInverter</a> (const std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt; &amp;probs) const</td></tr>
<tr class="separator:a77b6963ac7d92d55caade265c40af9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede4740894962881f21e1522349eb287" id="r_aede4740894962881f21e1522349eb287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aede4740894962881f21e1522349eb287">latentVarValue</a> (const std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt; &amp;allFactors, <a class="el" href="namespace_quant_lib.html#af4cc4ef40b52c17cc455ead2a97aedb3">Size</a> iVar) const</td></tr>
<tr class="separator:aede4740894962881f21e1522349eb287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56d8a54eabfb0d0216f472c727b65ac" id="r_ae56d8a54eabfb0d0216f472c727b65ac"><td class="memItemLeft" align="right" valign="top"><a id="ae56d8a54eabfb0d0216f472c727b65ac" name="ae56d8a54eabfb0d0216f472c727b65ac"></a>
const copulaType &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>copula</b> () const</td></tr>
<tr class="separator:ae56d8a54eabfb0d0216f472c727b65ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Integration facility interface</h2></td></tr>
<tr class="memitem:a416b1acb0a0321ba7eac54c1bc1c494d" id="r_a416b1acb0a0321ba7eac54c1bc1c494d"><td class="memItemLeft" align="right" valign="top"><a id="a416b1acb0a0321ba7eac54c1bc1c494d" name="a416b1acb0a0321ba7eac54c1bc1c494d"></a>
std::vector&lt; std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>factorWeights_</b></td></tr>
<tr class="separator:a416b1acb0a0321ba7eac54c1bc1c494d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e201047207fd50ca0725a2cb7a21d4" id="r_a68e201047207fd50ca0725a2cb7a21d4"><td class="memItemLeft" align="right" valign="top"><a id="a68e201047207fd50ca0725a2cb7a21d4" name="a68e201047207fd50ca0725a2cb7a21d4"></a>
<a class="el" href="class_quant_lib_1_1_handle.html">Handle</a>&lt; <a class="el" href="class_quant_lib_1_1_quote.html">Quote</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>cachedMktFactor_</b></td></tr>
<tr class="separator:a68e201047207fd50ca0725a2cb7a21d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f058b49788035828bbe2b3e78db9ebe" id="r_a4f058b49788035828bbe2b3e78db9ebe"><td class="memItemLeft" align="right" valign="top"><a id="a4f058b49788035828bbe2b3e78db9ebe" name="a4f058b49788035828bbe2b3e78db9ebe"></a>
std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>idiosyncFctrs_</b></td></tr>
<tr class="separator:a4f058b49788035828bbe2b3e78db9ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1daf4e28ce8ab5233065be60fd2896" id="r_acd1daf4e28ce8ab5233065be60fd2896"><td class="memItemLeft" align="right" valign="top"><a id="acd1daf4e28ce8ab5233065be60fd2896" name="acd1daf4e28ce8ab5233065be60fd2896"></a>
<a class="el" href="namespace_quant_lib.html#af4cc4ef40b52c17cc455ead2a97aedb3">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nFactors_</b></td></tr>
<tr class="memdesc:acd1daf4e28ce8ab5233065be60fd2896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of systemic factors. <br /></td></tr>
<tr class="separator:acd1daf4e28ce8ab5233065be60fd2896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e8cf454283157cab9a90b5aa261409" id="r_a43e8cf454283157cab9a90b5aa261409"><td class="memItemLeft" align="right" valign="top"><a id="a43e8cf454283157cab9a90b5aa261409" name="a43e8cf454283157cab9a90b5aa261409"></a>
<a class="el" href="namespace_quant_lib.html#af4cc4ef40b52c17cc455ead2a97aedb3">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nVariables_</b></td></tr>
<tr class="memdesc:a43e8cf454283157cab9a90b5aa261409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of latent model variables, idiosyncratic terms or model dim. <br /></td></tr>
<tr class="separator:a43e8cf454283157cab9a90b5aa261409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dbc85525bd7e1dfbf3a41591cabe27" id="r_aa3dbc85525bd7e1dfbf3a41591cabe27"><td class="memItemLeft" align="right" valign="top"><a id="aa3dbc85525bd7e1dfbf3a41591cabe27" name="aa3dbc85525bd7e1dfbf3a41591cabe27"></a>
copulaType&#160;</td><td class="memItemRight" valign="bottom"><b>copula_</b></td></tr>
<tr class="separator:aa3dbc85525bd7e1dfbf3a41591cabe27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f73847f26e632e54de23dc218e44875" id="r_a8f73847f26e632e54de23dc218e44875"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f73847f26e632e54de23dc218e44875">integratedExpectedValue</a> (const std::function&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a>(const std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt; &amp;v1)&gt; &amp;f) const</td></tr>
<tr class="separator:a8f73847f26e632e54de23dc218e44875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450b60907aff21aa12ef61c50206ec4b" id="r_a450b60907aff21aa12ef61c50206ec4b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a450b60907aff21aa12ef61c50206ec4b">integratedExpectedValueV</a> (const std::function&lt; std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt;(const std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt; &amp;v1)&gt; &amp;f) const</td></tr>
<tr class="separator:a450b60907aff21aa12ef61c50206ec4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89eb0c30269ba582f13776a19048c94b" id="r_a89eb0c30269ba582f13776a19048c94b"><td class="memItemLeft" align="right" valign="top">virtual const ext::shared_ptr&lt; <a class="el" href="class_quant_lib_1_1_l_m_integration.html">LMIntegration</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89eb0c30269ba582f13776a19048c94b">integration</a> () const</td></tr>
<tr class="separator:a89eb0c30269ba582f13776a19048c94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_class_quant_lib_1_1_observer"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_class_quant_lib_1_1_observer')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_quant_lib_1_1_observer.html">QuantLib::Observer</a></td></tr>
<tr class="memitem:ad45fa6f7242ee763d17c714a3e8bb6d7 inherit pub_types_class_quant_lib_1_1_observer" id="r_ad45fa6f7242ee763d17c714a3e8bb6d7"><td class="memItemLeft" align="right" valign="top">
typedef set_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:ad45fa6f7242ee763d17c714a3e8bb6d7 inherit pub_types_class_quant_lib_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class copulaPolicyImpl&gt;<br />
class QuantLib::LatentModel&lt; copulaPolicyImpl &gt;</div><p>Generic multifactor latent variable model. </p>
<dl class="section user"><dt></dt><dd>In this model set up one considers latent (random) variables <picture><source srcset="form_126_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ Y_i $" src="form_126.png"/></picture> described by:            <p class="formulaDsp">
<picture><source srcset="form_127_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[    \begin{array}{ccccc}
    Y_1 &amp; = &amp; \sum_k M_k a_{1,k} &amp; + \sqrt{1-\sum_k a_{1,k}^2} Z_1 &amp; 
        \sim \Phi_{Y_1}\nonumber \\
    ... &amp; = &amp;      ... &amp; ...   &amp; \nonumber \\
    Y_i &amp; = &amp; \sum_k M_k a_{i,k} &amp; + \sqrt{1-\sum_k a_{i,k}^2} Z_i &amp; 
        \sim \Phi_{Y_i}\nonumber \\
    ... &amp; = &amp;      ... &amp; ...   &amp; \nonumber \\
    Y_N &amp; = &amp; \sum_k M_k a_{N,k} &amp; + \sqrt{1-\sum_k a_{N,k}^2} Z_N &amp; 
        \sim \Phi_{Y_N}
    \end{array}
\]" src="form_127.png"/></picture>
</p>
 where the systemic <picture><source srcset="form_128_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ M_k $" src="form_128.png"/></picture> and idiosyncratic <picture><source srcset="form_87_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ Z_i $" src="form_87.png"/></picture> (this last one known as error term in some contexts) random variables have independent zero-mean unit-variance distributions. A restriction of the model implemented here is that the N idiosyncratic variables all follow the same probability law <picture><source srcset="form_129_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Phi_Z(z)$" src="form_129.png"/></picture> (but they are still independent random variables) Also the model is normalized so that: <picture><source srcset="form_130_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$-1\leq a_{i,k} \leq 1$" src="form_130.png"/></picture> (technically the <picture><source srcset="form_58_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$Y_i$" src="form_58.png"/></picture> are convex linear combinations). The correlation between <picture><source srcset="form_58_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$Y_i$" src="form_58.png"/></picture> and <picture><source srcset="form_59_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$Y_j$" src="form_59.png"/></picture> is then <picture><source srcset="form_131_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\sum_k a_{i,k} a_{j,k}$" src="form_131.png"/></picture>. <picture><source srcset="form_132_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\Phi_{Y_i}$" src="form_132.png"/></picture> denotes the cumulative distribution function of <picture><source srcset="form_58_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$Y_i$" src="form_58.png"/></picture> which in general differs for each latent variable.</dd></dl>
<dl class="section user"><dt></dt><dd>In its single factor set up this model is usually employed in derivative pricing and it is best to use it through integration of the desired statistical properties of the model; in its multifactorial version (with typically around a dozen factors) it is used in the context of portfolio risk metrics; because of the number of variables it is best to opt for a simulation to compute model properties/magnitudes. For this reason this class template provides a random factor sample interface and an integration interface that will be instantiated by derived concrete models as needed. The class is neutral on the integration and random generation algorithms</dd></dl>
<dl class="section user"><dt></dt><dd>The latent variables are typically treated as unobservable magnitudes and they serve to model one or several magnitudes related to them through some function       <p class="formulaDsp">
<picture><source srcset="form_133_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[    \begin{array}{ccc}
    F_i(Y_i) &amp; = &amp; 
        F_i(\sum_k M_k a_{i,k} + \sqrt{1-\sum_k a_{i,k}^2} Z_i )\nonumber \\
    &amp; = &amp; F_i(M_1,..., M_k, ..., M_K, Z_i)
    \end{array}
\]" src="form_133.png"/></picture>
</p>
 The transfer function can have a more generic form: <picture><source srcset="form_134_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$F_i(Y_1,....,Y_N)$" src="form_134.png"/></picture> but here the model is restricted to a one to one relation between the latent variables and the modelled ones. Also it is assumed that <picture><source srcset="form_135_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$F_i(y_i; \tau)$" src="form_135.png"/></picture> is monotonic in <picture><source srcset="form_136_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$y_i$" src="form_136.png"/></picture>; it can then be inverted and the relation of the cumulative probability of <picture><source srcset="form_137_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$F_i$" src="form_137.png"/></picture> and <picture><source srcset="form_58_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$Y_i$" src="form_58.png"/></picture> is simple:    <p class="formulaDsp">
<picture><source srcset="form_138_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[    \int_{\infty}^b \phi_{F_i} df = 
        \int_{\infty}^{F_i^{-1}(b)} \phi_{Y_i} dy
\]" src="form_138.png"/></picture>
</p>
 If <picture><source srcset="form_63_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$t$" src="form_63.png"/></picture> is some value of the functional or modelled variable, <picture><source srcset="form_62_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$y$" src="form_62.png"/></picture> is mapped to <picture><source srcset="form_63_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$t$" src="form_63.png"/></picture> such that percentiles match, i.e. <picture><source srcset="form_64_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$F_Y(y)=Q_i(t)$" src="form_64.png"/></picture> or <picture><source srcset="form_65_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$y=F_Y^{-1}(Q_i(t))$" src="form_65.png"/></picture>. The class provides an integration facility of arbitrary functions dependent on the model states. It also provides random number generation interfaces for usage of the model in monte carlo simulations.</dd></dl>
<dl class="section user"><dt></dt><dd>Now let <picture><source srcset="form_139_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\Phi_Z(z)$" src="form_139.png"/></picture> be the cumulated distribution function of (all equal as mentioned) <picture><source srcset="form_56_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$Z_i$" src="form_56.png"/></picture>. For a given realization of <picture><source srcset="form_140_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$M_k$" src="form_140.png"/></picture>, this determines the distribution of <picture><source srcset="form_62_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$y$" src="form_62.png"/></picture>:           <p class="formulaDsp">
<picture><source srcset="form_141_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[    Prob \,(Y_i &lt; y|M_k) = \Phi_Z \left( \frac{y-\sum_k a_{i,k}\,M_k}
        {\sqrt{1-\sum_k a_{i,k}^2}}\right)
    \qquad
    \mbox{or}
    \qquad
    Prob \,(t_i &lt; t|M) = \Phi_Z \left( \frac
        {F_{Y_{i}}^{-1}(Q_i(t))-\sum_k a_{i,k}\,M_k}
        {\sqrt{1-\sum_k a_{i,k}^2}}
    \right)
\]" src="form_141.png"/></picture>
</p>
 The distribution functions of <picture><source srcset="form_142_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ M_k, Z_i $" src="form_142.png"/></picture> are specified in specific copula template classes. The distribution function of <picture><source srcset="form_126_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ Y_i $" src="form_126.png"/></picture> is then given by the convolution             <p class="formulaDsp">
<picture><source srcset="form_143_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[    F_{Y_{i}}(y) = Prob\,(Y_i&lt;y) = 
    \int_{-\infty}^\infty\,\cdots\,\int_{-\infty}^{\infty}\:
    D_Z(z)\,\prod_k D_{M_{k}}(m_k) \quad
    \Theta \left(y - \sum_k a_{i,k}m_k - 
        \sqrt{1-\sum_k a_{i,k}^2}\,z\right)\,d\bar{m}\,dz,
    \qquad
    \Theta (x) = \left\{
    \begin{array}{ll}
    1 &amp; x \geq 0 \\
    0 &amp; x &lt; 0
    \end{array}\right.
\]" src="form_143.png"/></picture>
</p>
 where <picture><source srcset="form_71_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ D_Z(z) $" src="form_71.png"/></picture> and <picture><source srcset="form_72_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ D_M(m) $" src="form_72.png"/></picture> are the probability densities of <picture><source srcset="form_73_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ Z$" src="form_73.png"/></picture> and <picture><source srcset="form_74_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ M, $" src="form_74.png"/></picture> respectively.</dd></dl>
<dl class="section user"><dt></dt><dd>This convolution can also be written        <p class="formulaDsp">
<picture><source srcset="form_144_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[    F_{Y_{i}}(y) = Prob \,(Y_i &lt; y) =
    \int_{-\infty}^\infty\,\cdots\,\int_{-\infty}^{\infty} 
        D_{M_{k}}(m_k)\,dm_k\:
    \int_{-\infty}^{g(y,\vec{a},\vec{m})} D_Z(z)\,dz, \qquad
    g(y,\vec{a},\vec{m}) = \frac{y - \sum_k a_{i,k}m_k}
        {\sqrt{1-\sum_k a_{i,k}^2}}, \qquad \sum_k a_{i,k}^2 &lt; 1
\]" src="form_144.png"/></picture>
</p>
 In general, <picture><source srcset="form_145_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F_{Y_{i}}(y) $" src="form_145.png"/></picture> needs to be computed numerically.</dd></dl>
<dl class="section user"><dt></dt><dd>The policy class template separates the copula function (the distributions involved) and the functionality (i.e. what the latent <br  />
 model represents: a default probability, a recovery...). Since the <br  />
 copula methods for the probabilities are to be called repeatedly from an integration or a MC simulation, virtual tables are avoided and template parameter mechnics is preferred.</dd></dl>
<dl class="section user"><dt></dt><dd>There is nothing at this level enforncing the requirement on the factor distributions to be of zero mean and unit variance. Thats the user responsibility and the model fails to behave correctly if it is not the case.</dd></dl>
<dl class="section user"><dt></dt><dd>Derived classes should implement a modelled magnitude (default time, etc) and will provide probability distributions and conditional values. They could also provide functionality for the parameter inversion problem, the (e.g.) time at which the modeled variable first takes a given value. This problem has solution/sense depending on the transfer function <picture><source srcset="form_146_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$F_i(Y_i)$" src="form_146.png"/></picture> characteristics.</dd></dl>
<p>To make direct integration and simulation time efficient virtual functions have been avoided in accessing methods in the copula policy and in the sampling of the random factors </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2423b7437ca2ba9796e153bd9b9df050" name="a2423b7437ca2ba9796e153bd9b9df050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2423b7437ca2ba9796e153bd9b9df050">&#9670;&#160;</a></span>LatentModel() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class copulaPolicyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_quant_lib_1_1_latent_model.html">QuantLib::LatentModel</a>&lt; copulaPolicyImpl &gt;::LatentModel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>factorsWeights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename copulaType::initTraits &amp;</td>          <td class="paramname"><span class="paramname"><em>ini</em></span><span class="paramdefsep"> = </span><span class="paramdefval">typename&#160;copulaType::initTraits()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a LM with an arbitrary number of latent variables and factors given by the dimensions of the passed matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factorsWeights</td><td>Ordering is factorWeights_[iVar][iFactor] </td></tr>
    <tr><td class="paramname">ini</td><td>Initialization variables. Trait type from the copula policy to allow for static policies (this solution needs to be revised, possibly drop the static policy and create a policy member in <a class="el" href="class_quant_lib_1_1_latent_model.html" title="Generic multifactor latent variable model.">LatentModel</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a250ac646a6be88e253dc37c2620de9dd" name="a250ac646a6be88e253dc37c2620de9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250ac646a6be88e253dc37c2620de9dd">&#9670;&#160;</a></span>LatentModel() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class copulaPolicyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_quant_lib_1_1_latent_model.html">QuantLib::LatentModel</a>&lt; copulaPolicyImpl &gt;::LatentModel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>factorsWeight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename copulaType::initTraits &amp;</td>          <td class="paramname"><span class="paramname"><em>ini</em></span><span class="paramdefsep"> = </span><span class="paramdefval">typename&#160;copulaType::initTraits()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a LM with an arbitrary number of latent variables depending only on one random factor but contributing to each latent variable through different weights. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factorsWeight</td><td>Ordering is factorWeights_[iVariable] </td></tr>
    <tr><td class="paramname">ini</td><td>Initialization variables. Trait type from the copula policy to allow for static policies (this solution needs to be revised, possibly drop the static policy and create a policy member in <a class="el" href="class_quant_lib_1_1_latent_model.html" title="Generic multifactor latent variable model.">LatentModel</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a762ae56003287bdd2995e5a46a8c9f57" name="a762ae56003287bdd2995e5a46a8c9f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762ae56003287bdd2995e5a46a8c9f57">&#9670;&#160;</a></span>LatentModel() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class copulaPolicyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_quant_lib_1_1_latent_model.html">QuantLib::LatentModel</a>&lt; copulaPolicyImpl &gt;::LatentModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a></td>          <td class="paramname"><span class="paramname"><em>correlSqr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_quant_lib.html#af4cc4ef40b52c17cc455ead2a97aedb3">Size</a></td>          <td class="paramname"><span class="paramname"><em>nVariables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename copulaType::initTraits &amp;</td>          <td class="paramname"><span class="paramname"><em>ini</em></span><span class="paramdefsep"> = </span><span class="paramdefval">typename&#160;copulaType::initTraits()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a LM with an arbitrary number of latent variables depending only on one random factor with the same weight for all latent variables.</p>
<p>correlSqr is the weight, same for all.</p>
<p>ini is a trait type from the copula policy, to allow for static policies (this solution needs to be revised, possibly drop the static policy and create a policy member in <a class="el" href="class_quant_lib_1_1_latent_model.html" title="Generic multifactor latent variable model.">LatentModel</a>) </p>

</div>
</div>
<a id="a4200b7490c6d6690d2ec1df95d4862ba" name="a4200b7490c6d6690d2ec1df95d4862ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4200b7490c6d6690d2ec1df95d4862ba">&#9670;&#160;</a></span>LatentModel() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class copulaPolicyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_quant_lib_1_1_latent_model.html">QuantLib::LatentModel</a>&lt; copulaPolicyImpl &gt;::LatentModel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_quant_lib_1_1_handle.html">Handle</a>&lt; <a class="el" href="class_quant_lib_1_1_quote.html">Quote</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>singleFactorCorrel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_quant_lib.html#af4cc4ef40b52c17cc455ead2a97aedb3">Size</a></td>          <td class="paramname"><span class="paramname"><em>nVariables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename copulaType::initTraits &amp;</td>          <td class="paramname"><span class="paramname"><em>ini</em></span><span class="paramdefsep"> = </span><span class="paramdefval">typename&#160;copulaType::initTraits()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a LM with an arbitrary number of latent variables depending only on one random factor with the same weight for all latent variables. The weight is observed and this constructor is intended to be used when the model relates to a market value.</p>
<p>singleFactorCorrel is the weight/mkt-factor, same for all.</p>
<p>ini is a trait type from the copula policy, to allow for static policies (this solution needs to be revised, possibly drop the static policy and create a policy member in <a class="el" href="class_quant_lib_1_1_latent_model.html" title="Generic multifactor latent variable model.">LatentModel</a>) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a77b6963ac7d92d55caade265c40af9e4" name="a77b6963ac7d92d55caade265c40af9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b6963ac7d92d55caade265c40af9e4">&#9670;&#160;</a></span>allFactorCumulInverter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class copulaPolicyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt; <a class="el" href="class_quant_lib_1_1_latent_model.html">QuantLib::LatentModel</a>&lt; copulaPolicyImpl &gt;::allFactorCumulInverter </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>probs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All factor cumulative inversion. Used in integrations and sampling. Inverts all the cumulative random factors probabilities in the model. These are all the systemic factors plus all the idiosyncratic ones, so the size of the inversion is the number of systemic factors plus the number of latent modelled variables </p>

</div>
</div>
<a id="af159333d575c0b252de3c71371919dc2" name="af159333d575c0b252de3c71371919dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af159333d575c0b252de3c71371919dc2">&#9670;&#160;</a></span>cumulativeY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class copulaPolicyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_quant_lib.html#ac41728dd3be3e1869bbb9aec06a89d60">Probability</a> <a class="el" href="class_quant_lib_1_1_latent_model.html">QuantLib::LatentModel</a>&lt; copulaPolicyImpl &gt;::cumulativeY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_quant_lib.html#af4cc4ef40b52c17cc455ead2a97aedb3">Size</a></td>          <td class="paramname"><span class="paramname"><em>iVariable</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cumulative probability of the <picture><source srcset="form_126_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ Y_i $" src="form_126.png"/></picture> modelled latent random variable to take a given value. </p>

</div>
</div>
<a id="a8f73847f26e632e54de23dc218e44875" name="a8f73847f26e632e54de23dc218e44875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f73847f26e632e54de23dc218e44875">&#9670;&#160;</a></span>integratedExpectedValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class copulaPolicyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> <a class="el" href="class_quant_lib_1_1_latent_model.html">QuantLib::LatentModel</a>&lt; copulaPolicyImpl &gt;::integratedExpectedValue </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a>(const std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt; &amp;v1)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Integrates an arbitrary scalar function over the density domain(i.e. computes its expected value). </p>

</div>
</div>
<a id="a450b60907aff21aa12ef61c50206ec4b" name="a450b60907aff21aa12ef61c50206ec4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450b60907aff21aa12ef61c50206ec4b">&#9670;&#160;</a></span>integratedExpectedValueV()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class copulaPolicyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt; <a class="el" href="class_quant_lib_1_1_latent_model.html">QuantLib::LatentModel</a>&lt; copulaPolicyImpl &gt;::integratedExpectedValueV </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt;(const std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt; &amp;v1)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Integrates an arbitrary vector function over the density domain(i.e. computes its expected value). </p>

</div>
</div>
<a id="a89eb0c30269ba582f13776a19048c94b" name="a89eb0c30269ba582f13776a19048c94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89eb0c30269ba582f13776a19048c94b">&#9670;&#160;</a></span>integration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class copulaPolicyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const ext::shared_ptr&lt; <a class="el" href="class_quant_lib_1_1_l_m_integration.html">LMIntegration</a> &gt; &amp; <a class="el" href="class_quant_lib_1_1_latent_model.html">QuantLib::LatentModel</a>&lt; copulaPolicyImpl &gt;::integration </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_quant_lib_1_1_default_latent_model.html#a25bb529ee409a22cc0384aed147d0528">QuantLib::DefaultLatentModel&lt; copulaPolicy &gt;</a>, <a class="el" href="class_quant_lib_1_1_default_latent_model.html#a25bb529ee409a22cc0384aed147d0528">QuantLib::DefaultLatentModel&lt; GaussianCopulaPolicy &gt;</a>, <a class="el" href="class_quant_lib_1_1_default_latent_model.html#a25bb529ee409a22cc0384aed147d0528">QuantLib::DefaultLatentModel&lt; GaussianCopulaPolicy &gt;</a>, <a class="el" href="class_quant_lib_1_1_default_latent_model.html#a25bb529ee409a22cc0384aed147d0528">QuantLib::DefaultLatentModel&lt; TCopulaPolicy &gt;</a>, <a class="el" href="class_quant_lib_1_1_default_latent_model.html#a25bb529ee409a22cc0384aed147d0528">QuantLib::DefaultLatentModel&lt; TCopulaPolicy &gt;</a>, <a class="el" href="class_quant_lib_1_1_spot_recovery_latent_model.html#aa425c196023713f9809c02b9f896aaf5">QuantLib::SpotRecoveryLatentModel&lt; copulaPolicy &gt;</a>, <a class="el" href="class_quant_lib_1_1_spot_recovery_latent_model.html#aa425c196023713f9809c02b9f896aaf5">QuantLib::SpotRecoveryLatentModel&lt; GaussianCopulaPolicy &gt;</a>, <a class="el" href="class_quant_lib_1_1_spot_recovery_latent_model.html#aa425c196023713f9809c02b9f896aaf5">QuantLib::SpotRecoveryLatentModel&lt; GaussianCopulaPolicy &gt;</a>, <a class="el" href="class_quant_lib_1_1_spot_recovery_latent_model.html#aa425c196023713f9809c02b9f896aaf5">QuantLib::SpotRecoveryLatentModel&lt; TCopulaPolicy &gt;</a>, and <a class="el" href="class_quant_lib_1_1_spot_recovery_latent_model.html#aa425c196023713f9809c02b9f896aaf5">QuantLib::SpotRecoveryLatentModel&lt; TCopulaPolicy &gt;</a>.</p>

</div>
</div>
<a id="a8f4c7a3b52e2a50a88b3a2e67cc1109b" name="a8f4c7a3b52e2a50a88b3a2e67cc1109b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4c7a3b52e2a50a88b3a2e67cc1109b">&#9670;&#160;</a></span>inverseCumulativeY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class copulaPolicyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> <a class="el" href="class_quant_lib_1_1_latent_model.html">QuantLib::LatentModel</a>&lt; copulaPolicyImpl &gt;::inverseCumulativeY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_quant_lib.html#ac41728dd3be3e1869bbb9aec06a89d60">Probability</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_quant_lib.html#af4cc4ef40b52c17cc455ead2a97aedb3">Size</a></td>          <td class="paramname"><span class="paramname"><em>iVariable</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inverse cumulative value of the i-th random latent variable with a given probability. </p>

</div>
</div>
<a id="a28355f257003546d33fda003452c820e" name="a28355f257003546d33fda003452c820e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28355f257003546d33fda003452c820e">&#9670;&#160;</a></span>inverseCumulativeZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class copulaPolicyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> <a class="el" href="class_quant_lib_1_1_latent_model.html">QuantLib::LatentModel</a>&lt; copulaPolicyImpl &gt;::inverseCumulativeZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_quant_lib.html#ac41728dd3be3e1869bbb9aec06a89d60">Probability</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inverse cumulative value of the idiosyncratic variable with a given probability. </p>

</div>
</div>
<a id="aede4740894962881f21e1522349eb287" name="aede4740894962881f21e1522349eb287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede4740894962881f21e1522349eb287">&#9670;&#160;</a></span>latentVarValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class copulaPolicyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> <a class="el" href="class_quant_lib_1_1_latent_model.html">QuantLib::LatentModel</a>&lt; copulaPolicyImpl &gt;::latentVarValue </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespace_quant_lib.html#a372ac5c1a422a6b276fe0552d4d83f50">Real</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>allFactors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_quant_lib.html#af4cc4ef40b52c17cc455ead2a97aedb3">Size</a></td>          <td class="paramname"><span class="paramname"><em>iVar</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The value of the latent variable Y_i conditional to (given) a set of values of the factors.</p>
<p>The passed allFactors vector contains values for all the independent factors in the model (systemic and idiosyncratic, in that order). A full sample is required, i.e. all the idiosyncratic values are expected to be present even if only the relevant one is used. </p>

</div>
</div>
<a id="a25404a7f39fe1422f6e4dd1fb9b67115" name="a25404a7f39fe1422f6e4dd1fb9b67115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25404a7f39fe1422f6e4dd1fb9b67115">&#9670;&#160;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_quant_lib_1_1_latent_model.html">QuantLib::LatentModel</a>&lt; Impl &gt;::update </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method must be implemented in derived classes. An instance of Observer does not call this method directly: instead, it will be called by the observables the instance registered with when they need to notify any changes. </p>

<p>Implements <a class="el" href="class_quant_lib_1_1_observer.html#a07905c55dca858470fcf4a1aea0005aa">QuantLib::Observer</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ql/experimental/math/<a class="el" href="latentmodel_8hpp_source.html">latentmodel.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_quant_lib.html">QuantLib</a></li><li class="navelem"><a class="el" href="class_quant_lib_1_1_latent_model.html">LatentModel</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
