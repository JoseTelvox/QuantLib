<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.13.2" xml:lang="en-US">
  <compounddef id="class_quant_lib_1_1_latent_model" kind="class" language="C++" prot="public">
    <compoundname>QuantLib::LatentModel</compoundname>
    <basecompoundref refid="class_quant_lib_1_1_observer" prot="public" virt="virtual">QuantLib::Observer</basecompoundref>
    <basecompoundref refid="class_quant_lib_1_1_observable" prot="public" virt="virtual">QuantLib::Observable</basecompoundref>
    <derivedcompoundref refid="class_quant_lib_1_1_default_latent_model" prot="public" virt="non-virtual">QuantLib::DefaultLatentModel&lt; TCopulaPolicy &gt;</derivedcompoundref>
    <derivedcompoundref refid="class_quant_lib_1_1_spot_recovery_latent_model" prot="public" virt="non-virtual">QuantLib::SpotRecoveryLatentModel&lt; TCopulaPolicy &gt;</derivedcompoundref>
    <includes refid="latentmodel_8hpp" local="no">latentmodel.hpp</includes>
    <innerclass refid="class_quant_lib_1_1_latent_model_1_1_factor_sampler" prot="public">QuantLib::LatentModel::FactorSampler</innerclass>
    <innerclass refid="class_quant_lib_1_1_latent_model_1_1_integration_factory" prot="protected">QuantLib::LatentModel::IntegrationFactory</innerclass>
    <templateparamlist>
      <param>
        <type>class copulaPolicyImpl</type>
      </param>
    </templateparamlist>
    <sectiondef kind="user-defined">
      <header>Copula interface.</header>
      <memberdef kind="typedef" id="class_quant_lib_1_1_latent_model_1aad1fd370b3f36c3cf24b661d189fed01" prot="public" static="no">
        <type>copulaPolicyImpl</type>
        <definition>typedef copulaPolicyImpl QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::copulaType</definition>
        <argsstring></argsstring>
        <name>copulaType</name>
        <qualifiedname>QuantLib::LatentModel::copulaType</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="285" column="32" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="285" bodyend="-1"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1af159333d575c0b252de3c71371919dc2" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespace_quant_lib_1ac41728dd3be3e1869bbb9aec06a89d60" kindref="member">Probability</ref></type>
        <definition>Probability QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::cumulativeY</definition>
        <argsstring>(Real val, Size iVariable) const</argsstring>
        <name>cumulativeY</name>
        <qualifiedname>QuantLib::LatentModel::cumulativeY</qualifiedname>
        <param>
          <type><ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref></type>
          <declname>val</declname>
        </param>
        <param>
          <type><ref refid="namespace_quant_lib_1af4cc4ef40b52c17cc455ead2a97aedb3" kindref="member">Size</ref></type>
          <declname>iVariable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Cumulative probability of the <formula id="126">$ Y_i $</formula> modelled latent random variable to take a given value. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="289" column="19" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="289" bodyend="291"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1ae64724a9ecdc4cb7dadd555b019da10b" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespace_quant_lib_1ac41728dd3be3e1869bbb9aec06a89d60" kindref="member">Probability</ref></type>
        <definition>Probability QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::cumulativeZ</definition>
        <argsstring>(Real z) const</argsstring>
        <name>cumulativeZ</name>
        <qualifiedname>QuantLib::LatentModel::cumulativeZ</qualifiedname>
        <param>
          <type><ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref></type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Cumulative distribution of Z, the idiosyncratic/error factors. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="293" column="21" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="293" bodyend="295"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1a9711849d61e8bc79608424661ac9dde2" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespace_quant_lib_1ac41728dd3be3e1869bbb9aec06a89d60" kindref="member">Probability</ref></type>
        <definition>Probability QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::density</definition>
        <argsstring>(const std::vector&lt; Real &gt; &amp;m) const</argsstring>
        <name>density</name>
        <qualifiedname>QuantLib::LatentModel::density</qualifiedname>
        <param>
          <type>const std::vector&lt; <ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Density function of M, the market/systemic factors. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="297" column="21" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="297" bodyend="303"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1a10f1e843503876609d1cb14ac9b26c8e" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref></type>
        <definition>Real QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::inverseCumulativeDensity</definition>
        <argsstring>(Probability p, Size iFactor) const</argsstring>
        <name>inverseCumulativeDensity</name>
        <qualifiedname>QuantLib::LatentModel::inverseCumulativeDensity</qualifiedname>
        <param>
          <type><ref refid="namespace_quant_lib_1ac41728dd3be3e1869bbb9aec06a89d60" kindref="member">Probability</ref></type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="namespace_quant_lib_1af4cc4ef40b52c17cc455ead2a97aedb3" kindref="member">Size</ref></type>
          <declname>iFactor</declname>
        </param>
        <briefdescription>
<para>Inverse cumulative distribution of the systemic factor iFactor. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="305" column="14" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="305" bodyend="307"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1a8f4c7a3b52e2a50a88b3a2e67cc1109b" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref></type>
        <definition>Real QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::inverseCumulativeY</definition>
        <argsstring>(Probability p, Size iVariable) const</argsstring>
        <name>inverseCumulativeY</name>
        <qualifiedname>QuantLib::LatentModel::inverseCumulativeY</qualifiedname>
        <param>
          <type><ref refid="namespace_quant_lib_1ac41728dd3be3e1869bbb9aec06a89d60" kindref="member">Probability</ref></type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="namespace_quant_lib_1af4cc4ef40b52c17cc455ead2a97aedb3" kindref="member">Size</ref></type>
          <declname>iVariable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Inverse cumulative value of the i-th random latent variable with a given probability. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="310" column="14" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="310" bodyend="312"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1a28355f257003546d33fda003452c820e" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref></type>
        <definition>Real QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::inverseCumulativeZ</definition>
        <argsstring>(Probability p) const</argsstring>
        <name>inverseCumulativeZ</name>
        <qualifiedname>QuantLib::LatentModel::inverseCumulativeZ</qualifiedname>
        <param>
          <type><ref refid="namespace_quant_lib_1ac41728dd3be3e1869bbb9aec06a89d60" kindref="member">Probability</ref></type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Inverse cumulative value of the idiosyncratic variable with a given probability. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="315" column="14" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="315" bodyend="317"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1a77b6963ac7d92d55caade265c40af9e4" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>std::vector&lt; <ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref> &gt;</type>
        <definition>std::vector&lt; Real &gt; QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::allFactorCumulInverter</definition>
        <argsstring>(const std::vector&lt; Real &gt; &amp;probs) const</argsstring>
        <name>allFactorCumulInverter</name>
        <qualifiedname>QuantLib::LatentModel::allFactorCumulInverter</qualifiedname>
        <param>
          <type>const std::vector&lt; <ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>probs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>All factor cumulative inversion. Used in integrations and sampling. Inverts all the cumulative random factors probabilities in the model. These are all the systemic factors plus all the idiosyncratic ones, so the size of the inversion is the number of systemic factors plus the number of latent modelled variables </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="323" column="21" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="323" bodyend="325"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1aede4740894962881f21e1522349eb287" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref></type>
        <definition>Real QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::latentVarValue</definition>
        <argsstring>(const std::vector&lt; Real &gt; &amp;allFactors, Size iVar) const</argsstring>
        <name>latentVarValue</name>
        <qualifiedname>QuantLib::LatentModel::latentVarValue</qualifiedname>
        <param>
          <type>const std::vector&lt; <ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>allFactors</declname>
        </param>
        <param>
          <type><ref refid="namespace_quant_lib_1af4cc4ef40b52c17cc455ead2a97aedb3" kindref="member">Size</ref></type>
          <declname>iVar</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The value of the latent variable Y_i conditional to (given) a set of values of the factors.</para>
<para>The passed allFactors vector contains values for all the independent factors in the model (systemic and idiosyncratic, in that order). A full sample is required, i.e. all the idiosyncratic values are expected to be present even if only the relevant one is used. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="337" column="14" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="337" bodyend="345"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1ae56d8a54eabfb0d0216f472c727b65ac" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const copulaType &amp;</type>
        <definition>const copulaType &amp; QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::copula</definition>
        <argsstring>() const</argsstring>
        <name>copula</name>
        <qualifiedname>QuantLib::LatentModel::copula</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="348" column="26" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="348" bodyend="350"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="user-defined">
      <header>Integration facility interface</header>
      <memberdef kind="variable" id="class_quant_lib_1_1_latent_model_1a416b1acb0a0321ba7eac54c1bc1c494d" prot="protected" static="no" mutable="yes">
        <type>std::vector&lt; std::vector&lt; <ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref> &gt; &gt;</type>
        <definition>std::vector&lt;std::vector&lt;Real&gt; &gt; QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::factorWeights_</definition>
        <argsstring></argsstring>
        <name>factorWeights_</name>
        <qualifiedname>QuantLib::LatentModel::factorWeights_</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="608" column="29" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="608" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_quant_lib_1_1_latent_model_1a68e201047207fd50ca0725a2cb7a21d4" prot="protected" static="no" mutable="yes">
        <type><ref refid="class_quant_lib_1_1_handle" kindref="compound">Handle</ref>&lt; <ref refid="class_quant_lib_1_1_quote" kindref="compound">Quote</ref> &gt;</type>
        <definition>Handle&lt;Quote&gt; QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::cachedMktFactor_</definition>
        <argsstring></argsstring>
        <name>cachedMktFactor_</name>
        <qualifiedname>QuantLib::LatentModel::cachedMktFactor_</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="622" column="24" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="622" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_quant_lib_1_1_latent_model_1a4f058b49788035828bbe2b3e78db9ebe" prot="protected" static="no" mutable="yes">
        <type>std::vector&lt; <ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref> &gt;</type>
        <definition>std::vector&lt;Real&gt; QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::idiosyncFctrs_</definition>
        <argsstring></argsstring>
        <name>idiosyncFctrs_</name>
        <qualifiedname>QuantLib::LatentModel::idiosyncFctrs_</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="627" column="29" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="627" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_quant_lib_1_1_latent_model_1acd1daf4e28ce8ab5233065be60fd2896" prot="protected" static="no" mutable="yes">
        <type><ref refid="namespace_quant_lib_1af4cc4ef40b52c17cc455ead2a97aedb3" kindref="member">Size</ref></type>
        <definition>Size QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::nFactors_</definition>
        <argsstring></argsstring>
        <name>nFactors_</name>
        <qualifiedname>QuantLib::LatentModel::nFactors_</qualifiedname>
        <briefdescription>
<para>Number of systemic factors. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="629" column="22" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="629" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_quant_lib_1_1_latent_model_1a43e8cf454283157cab9a90b5aa261409" prot="protected" static="no" mutable="yes">
        <type><ref refid="namespace_quant_lib_1af4cc4ef40b52c17cc455ead2a97aedb3" kindref="member">Size</ref></type>
        <definition>Size QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::nVariables_</definition>
        <argsstring></argsstring>
        <name>nVariables_</name>
        <qualifiedname>QuantLib::LatentModel::nVariables_</qualifiedname>
        <briefdescription>
<para>Number of latent model variables, idiosyncratic terms or model dim. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="631" column="22" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="631" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_quant_lib_1_1_latent_model_1aa3dbc85525bd7e1dfbf3a41591cabe27" prot="protected" static="no" mutable="yes">
        <type>copulaType</type>
        <definition>copulaType QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::copula_</definition>
        <argsstring></argsstring>
        <name>copula_</name>
        <qualifiedname>QuantLib::LatentModel::copula_</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="633" column="28" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="633" bodyend="-1"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1a8f73847f26e632e54de23dc218e44875" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref></type>
        <definition>Real QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::integratedExpectedValue</definition>
        <argsstring>(const std::function&lt; Real(const std::vector&lt; Real &gt; &amp;v1)&gt; &amp;f) const</argsstring>
        <name>integratedExpectedValue</name>
        <qualifiedname>QuantLib::LatentModel::integratedExpectedValue</qualifiedname>
        <param>
          <type>const std::function&lt; <ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref>(const std::vector&lt; <ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref> &gt; &amp;v1)&gt; &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Integrates an arbitrary scalar function over the density domain(i.e. computes its expected value). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="580" column="14" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="580" bodyend="586"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1a450b60907aff21aa12ef61c50206ec4b" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>std::vector&lt; <ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref> &gt;</type>
        <definition>std::vector&lt; Real &gt; QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::integratedExpectedValueV</definition>
        <argsstring>(const std::function&lt; std::vector&lt; Real &gt;(const std::vector&lt; Real &gt; &amp;v1)&gt; &amp;f) const</argsstring>
        <name>integratedExpectedValueV</name>
        <qualifiedname>QuantLib::LatentModel::integratedExpectedValueV</qualifiedname>
        <param>
          <type>const std::function&lt; std::vector&lt; <ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref> &gt;(const std::vector&lt; <ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref> &gt; &amp;v1)&gt; &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Integrates an arbitrary vector function over the density domain(i.e. computes its expected value). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="590" column="21" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="590" bodyend="597"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1a89eb0c30269ba582f13776a19048c94b" prot="protected" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>const ext::shared_ptr&lt; <ref refid="class_quant_lib_1_1_l_m_integration" kindref="compound">LMIntegration</ref> &gt; &amp;</type>
        <definition>virtual const ext::shared_ptr&lt; LMIntegration &gt; &amp; QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::integration</definition>
        <argsstring>() const</argsstring>
        <name>integration</name>
        <qualifiedname>QuantLib::LatentModel::integration</qualifiedname>
        <reimplementedby refid="class_quant_lib_1_1_default_latent_model_1a25bb529ee409a22cc0384aed147d0528">integration</reimplementedby>
        <reimplementedby refid="class_quant_lib_1_1_default_latent_model_1a25bb529ee409a22cc0384aed147d0528">integration</reimplementedby>
        <reimplementedby refid="class_quant_lib_1_1_default_latent_model_1a25bb529ee409a22cc0384aed147d0528">integration</reimplementedby>
        <reimplementedby refid="class_quant_lib_1_1_default_latent_model_1a25bb529ee409a22cc0384aed147d0528">integration</reimplementedby>
        <reimplementedby refid="class_quant_lib_1_1_default_latent_model_1a25bb529ee409a22cc0384aed147d0528">integration</reimplementedby>
        <reimplementedby refid="class_quant_lib_1_1_spot_recovery_latent_model_1aa425c196023713f9809c02b9f896aaf5">integration</reimplementedby>
        <reimplementedby refid="class_quant_lib_1_1_spot_recovery_latent_model_1aa425c196023713f9809c02b9f896aaf5">integration</reimplementedby>
        <reimplementedby refid="class_quant_lib_1_1_spot_recovery_latent_model_1aa425c196023713f9809c02b9f896aaf5">integration</reimplementedby>
        <reimplementedby refid="class_quant_lib_1_1_spot_recovery_latent_model_1aa425c196023713f9809c02b9f896aaf5">integration</reimplementedby>
        <reimplementedby refid="class_quant_lib_1_1_spot_recovery_latent_model_1aa425c196023713f9809c02b9f896aaf5">integration</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="602" column="39" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="602" bodyend="604"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="user-defined">
      <header>Latent model direct integration facility.</header>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1a25404a7f39fe1422f6e4dd1fb9b67115" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void QuantLib::LatentModel&lt; Impl &gt;::update</definition>
        <argsstring>() override</argsstring>
        <name>update</name>
        <qualifiedname>QuantLib::LatentModel::update</qualifiedname>
        <reimplements refid="class_quant_lib_1_1_observer_1a07905c55dca858470fcf4a1aea0005aa">update</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This method must be implemented in derived classes. An instance of Observer does not call this method directly: instead, it will be called by the observables the instance registered with when they need to notify any changes. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="282" column="12" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="710" bodyend="722"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="user-defined">
      <header>Latent model random factor number generator facility.</header>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1a1dedcee7cecd341a0ed6131577b2f48e" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespace_quant_lib_1af4cc4ef40b52c17cc455ead2a97aedb3" kindref="member">Size</ref></type>
        <definition>Size QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::size</definition>
        <argsstring>() const</argsstring>
        <name>size</name>
        <qualifiedname>QuantLib::LatentModel::size</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="498" column="14" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="498" bodyend="498"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1ad410d410b17c524efa114598a0455936" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespace_quant_lib_1af4cc4ef40b52c17cc455ead2a97aedb3" kindref="member">Size</ref></type>
        <definition>Size QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::numFactors</definition>
        <argsstring>() const</argsstring>
        <name>numFactors</name>
        <qualifiedname>QuantLib::LatentModel::numFactors</qualifiedname>
        <briefdescription>
<para>Number of systemic factors. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="500" column="14" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="500" bodyend="500"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1a752c04c15550a49537c7eb0557bd6b16" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespace_quant_lib_1af4cc4ef40b52c17cc455ead2a97aedb3" kindref="member">Size</ref></type>
        <definition>Size QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::numTotalFactors</definition>
        <argsstring>() const</argsstring>
        <name>numTotalFactors</name>
        <qualifiedname>QuantLib::LatentModel::numTotalFactors</qualifiedname>
        <briefdescription>
<para>Number of total free random factors; systemic and idiosyncratic. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="502" column="14" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="502" bodyend="502"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1a2423b7437ca2ba9796e153bd9b9df050" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::LatentModel</definition>
        <argsstring>(const std::vector&lt; std::vector&lt; Real &gt; &gt; &amp;factorsWeights, const typename copulaType::initTraits &amp;ini=typename copulaType::initTraits())</argsstring>
        <name>LatentModel</name>
        <qualifiedname>QuantLib::LatentModel::LatentModel</qualifiedname>
        <param>
          <type>const std::vector&lt; std::vector&lt; <ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref> &gt; &gt; &amp;</type>
          <declname>factorsWeights</declname>
        </param>
        <param>
          <type>const typename copulaType::initTraits &amp;</type>
          <declname>ini</declname>
          <defval>typename copulaType::initTraits()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Constructs a LM with an arbitrary number of latent variables and factors given by the dimensions of the passed matrix. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>factorsWeights</parametername>
</parameternamelist>
<parameterdescription>
<para>Ordering is factorWeights_[iVar][iFactor] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ini</parametername>
</parameternamelist>
<parameterdescription>
<para>Initialization variables. Trait type from the copula policy to allow for static policies (this solution needs to be revised, possibly drop the static policy and create a policy member in <ref refid="class_quant_lib_1_1_latent_model" kindref="compound">LatentModel</ref>) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="512" column="18"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1a250ac646a6be88e253dc37c2620de9dd" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::LatentModel</definition>
        <argsstring>(const std::vector&lt; Real &gt; &amp;factorsWeight, const typename copulaType::initTraits &amp;ini=typename copulaType::initTraits())</argsstring>
        <name>LatentModel</name>
        <qualifiedname>QuantLib::LatentModel::LatentModel</qualifiedname>
        <param>
          <type>const std::vector&lt; <ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>factorsWeight</declname>
        </param>
        <param>
          <type>const typename copulaType::initTraits &amp;</type>
          <declname>ini</declname>
          <defval>typename copulaType::initTraits()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Constructs a LM with an arbitrary number of latent variables depending only on one random factor but contributing to each latent variable through different weights. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>factorsWeight</parametername>
</parameternamelist>
<parameterdescription>
<para>Ordering is factorWeights_[iVariable] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ini</parametername>
</parameternamelist>
<parameterdescription>
<para>Initialization variables. Trait type from the copula policy to allow for static policies (this solution needs to be revised, possibly drop the static policy and create a policy member in <ref refid="class_quant_lib_1_1_latent_model" kindref="compound">LatentModel</ref>) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="525" column="18"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1a762ae56003287bdd2995e5a46a8c9f57" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::LatentModel</definition>
        <argsstring>(Real correlSqr, Size nVariables, const typename copulaType::initTraits &amp;ini=typename copulaType::initTraits())</argsstring>
        <name>LatentModel</name>
        <qualifiedname>QuantLib::LatentModel::LatentModel</qualifiedname>
        <param>
          <type><ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref></type>
          <declname>correlSqr</declname>
        </param>
        <param>
          <type><ref refid="namespace_quant_lib_1af4cc4ef40b52c17cc455ead2a97aedb3" kindref="member">Size</ref></type>
          <declname>nVariables</declname>
        </param>
        <param>
          <type>const typename copulaType::initTraits &amp;</type>
          <declname>ini</declname>
          <defval>typename copulaType::initTraits()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Constructs a LM with an arbitrary number of latent variables depending only on one random factor with the same weight for all latent variables.</para>
<para>correlSqr is the weight, same for all.</para>
<para>ini is a trait type from the copula policy, to allow for static policies (this solution needs to be revised, possibly drop the static policy and create a policy member in <ref refid="class_quant_lib_1_1_latent_model" kindref="compound">LatentModel</ref>) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="539" column="18"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1a4200b7490c6d6690d2ec1df95d4862ba" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::LatentModel</definition>
        <argsstring>(const Handle&lt; Quote &gt; &amp;singleFactorCorrel, Size nVariables, const typename copulaType::initTraits &amp;ini=typename copulaType::initTraits())</argsstring>
        <name>LatentModel</name>
        <qualifiedname>QuantLib::LatentModel::LatentModel</qualifiedname>
        <param>
          <type>const <ref refid="class_quant_lib_1_1_handle" kindref="compound">Handle</ref>&lt; <ref refid="class_quant_lib_1_1_quote" kindref="compound">Quote</ref> &gt; &amp;</type>
          <declname>singleFactorCorrel</declname>
        </param>
        <param>
          <type><ref refid="namespace_quant_lib_1af4cc4ef40b52c17cc455ead2a97aedb3" kindref="member">Size</ref></type>
          <declname>nVariables</declname>
        </param>
        <param>
          <type>const typename copulaType::initTraits &amp;</type>
          <declname>ini</declname>
          <defval>typename copulaType::initTraits()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Constructs a LM with an arbitrary number of latent variables depending only on one random factor with the same weight for all latent variables. The weight is observed and this constructor is intended to be used when the model relates to a market value.</para>
<para>singleFactorCorrel is the weight/mkt-factor, same for all.</para>
<para>ini is a trait type from the copula policy, to allow for static policies (this solution needs to be revised, possibly drop the static policy and create a policy member in <ref refid="class_quant_lib_1_1_latent_model" kindref="compound">LatentModel</ref>) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="554" column="18"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1a9058f44d45963e20631cf813f500ed50" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const std::vector&lt; std::vector&lt; <ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref> &gt; &gt; &amp;</type>
        <definition>const std::vector&lt; std::vector&lt; Real &gt; &gt; &amp; QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::factorWeights</definition>
        <argsstring>() const</argsstring>
        <name>factorWeights</name>
        <qualifiedname>QuantLib::LatentModel::factorWeights</qualifiedname>
        <briefdescription>
<para>Provides values of the factors <formula id="147">$ a_{i,k} $</formula>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="560" column="27" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="560" bodyend="562"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1ad630746a257d3e970ecf83cd47878cd3" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const std::vector&lt; <ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref> &gt; &amp;</type>
        <definition>const std::vector&lt; Real &gt; &amp; QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::idiosyncFctrs</definition>
        <argsstring>() const</argsstring>
        <name>idiosyncFctrs</name>
        <qualifiedname>QuantLib::LatentModel::idiosyncFctrs</qualifiedname>
        <briefdescription>
<para>Provides values of the normalized idiosyncratic factors <formula id="87">$ Z_i $</formula>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="564" column="27" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="564" bodyend="564"/>
      </memberdef>
      <memberdef kind="function" id="class_quant_lib_1_1_latent_model_1a9d3034be325054187dfafbd5f7ef1890" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespace_quant_lib_1a372ac5c1a422a6b276fe0552d4d83f50" kindref="member">Real</ref></type>
        <definition>Real QuantLib::LatentModel&lt; copulaPolicyImpl &gt;::latentVariableCorrel</definition>
        <argsstring>(Size iVar1, Size iVar2) const</argsstring>
        <name>latentVariableCorrel</name>
        <qualifiedname>QuantLib::LatentModel::latentVariableCorrel</qualifiedname>
        <param>
          <type><ref refid="namespace_quant_lib_1af4cc4ef40b52c17cc455ead2a97aedb3" kindref="member">Size</ref></type>
          <declname>iVar1</declname>
        </param>
        <param>
          <type><ref refid="namespace_quant_lib_1af4cc4ef40b52c17cc455ead2a97aedb3" kindref="member">Size</ref></type>
          <declname>iVar2</declname>
        </param>
        <briefdescription>
<para>Latent variable correlations: </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="ql/experimental/math/latentmodel.hpp" line="567" column="14" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="567" bodyend="574"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>Generic multifactor latent variable model. </para>
    </briefdescription>
    <detaileddescription>
<para><simplesect kind="par"><title></title><para>In this model set up one considers latent (random) variables <formula id="126">$ Y_i $</formula> described by:            <formula id="127">\[    \begin{array}{ccccc}
    Y_1 &amp; = &amp; \sum_k M_k a_{1,k} &amp; + \sqrt{1-\sum_k a_{1,k}^2} Z_1 &amp; 
        \sim \Phi_{Y_1}\nonumber \\
    ... &amp; = &amp;      ... &amp; ...   &amp; \nonumber \\
    Y_i &amp; = &amp; \sum_k M_k a_{i,k} &amp; + \sqrt{1-\sum_k a_{i,k}^2} Z_i &amp; 
        \sim \Phi_{Y_i}\nonumber \\
    ... &amp; = &amp;      ... &amp; ...   &amp; \nonumber \\
    Y_N &amp; = &amp; \sum_k M_k a_{N,k} &amp; + \sqrt{1-\sum_k a_{N,k}^2} Z_N &amp; 
        \sim \Phi_{Y_N}
    \end{array}
\]</formula> where the systemic <formula id="128">$ M_k $</formula> and idiosyncratic <formula id="87">$ Z_i $</formula> (this last one known as error term in some contexts) random variables have independent zero-mean unit-variance distributions. A restriction of the model implemented here is that the N idiosyncratic variables all follow the same probability law <formula id="129">$ \Phi_Z(z)$</formula> (but they are still independent random variables) Also the model is normalized so that: <formula id="130">$-1\leq a_{i,k} \leq 1$</formula> (technically the <formula id="58">$Y_i$</formula> are convex linear combinations). The correlation between <formula id="58">$Y_i$</formula> and <formula id="59">$Y_j$</formula> is then <formula id="131">$\sum_k a_{i,k} a_{j,k}$</formula>. <formula id="132">$\Phi_{Y_i}$</formula> denotes the cumulative distribution function of <formula id="58">$Y_i$</formula> which in general differs for each latent variable.</para>
</simplesect>
<simplesect kind="par"><title></title><para>In its single factor set up this model is usually employed in derivative pricing and it is best to use it through integration of the desired statistical properties of the model; in its multifactorial version (with typically around a dozen factors) it is used in the context of portfolio risk metrics; because of the number of variables it is best to opt for a simulation to compute model properties/magnitudes. For this reason this class template provides a random factor sample interface and an integration interface that will be instantiated by derived concrete models as needed. The class is neutral on the integration and random generation algorithms</para>
</simplesect>
<simplesect kind="par"><title></title><para>The latent variables are typically treated as unobservable magnitudes and they serve to model one or several magnitudes related to them through some function       <formula id="133">\[    \begin{array}{ccc}
    F_i(Y_i) &amp; = &amp; 
        F_i(\sum_k M_k a_{i,k} + \sqrt{1-\sum_k a_{i,k}^2} Z_i )\nonumber \\
    &amp; = &amp; F_i(M_1,..., M_k, ..., M_K, Z_i)
    \end{array}
\]</formula> The transfer function can have a more generic form: <formula id="134">$F_i(Y_1,....,Y_N)$</formula> but here the model is restricted to a one to one relation between the latent variables and the modelled ones. Also it is assumed that <formula id="135">$F_i(y_i; \tau)$</formula> is monotonic in <formula id="136">$y_i$</formula>; it can then be inverted and the relation of the cumulative probability of <formula id="137">$F_i$</formula> and <formula id="58">$Y_i$</formula> is simple:    <formula id="138">\[    \int_{\infty}^b \phi_{F_i} df = 
        \int_{\infty}^{F_i^{-1}(b)} \phi_{Y_i} dy
\]</formula> If <formula id="63">$t$</formula> is some value of the functional or modelled variable, <formula id="62">$y$</formula> is mapped to <formula id="63">$t$</formula> such that percentiles match, i.e. <formula id="64">$F_Y(y)=Q_i(t)$</formula> or <formula id="65">$y=F_Y^{-1}(Q_i(t))$</formula>. The class provides an integration facility of arbitrary functions dependent on the model states. It also provides random number generation interfaces for usage of the model in monte carlo simulations.</para>
</simplesect>
<simplesect kind="par"><title></title><para>Now let <formula id="139">$\Phi_Z(z)$</formula> be the cumulated distribution function of (all equal as mentioned) <formula id="56">$Z_i$</formula>. For a given realization of <formula id="140">$M_k$</formula>, this determines the distribution of <formula id="62">$y$</formula>:           <formula id="141">\[    Prob \,(Y_i &lt; y|M_k) = \Phi_Z \left( \frac{y-\sum_k a_{i,k}\,M_k}
        {\sqrt{1-\sum_k a_{i,k}^2}}\right)
    \qquad
    \mbox{or}
    \qquad
    Prob \,(t_i &lt; t|M) = \Phi_Z \left( \frac
        {F_{Y_{i}}^{-1}(Q_i(t))-\sum_k a_{i,k}\,M_k}
        {\sqrt{1-\sum_k a_{i,k}^2}}
    \right)
\]</formula> The distribution functions of <formula id="142">$ M_k, Z_i $</formula> are specified in specific copula template classes. The distribution function of <formula id="126">$ Y_i $</formula> is then given by the convolution             <formula id="143">\[    F_{Y_{i}}(y) = Prob\,(Y_i&lt;y) = 
    \int_{-\infty}^\infty\,\cdots\,\int_{-\infty}^{\infty}\:
    D_Z(z)\,\prod_k D_{M_{k}}(m_k) \quad
    \Theta \left(y - \sum_k a_{i,k}m_k - 
        \sqrt{1-\sum_k a_{i,k}^2}\,z\right)\,d\bar{m}\,dz,
    \qquad
    \Theta (x) = \left\{
    \begin{array}{ll}
    1 &amp; x \geq 0 \\
    0 &amp; x &lt; 0
    \end{array}\right.
\]</formula> where <formula id="71">$ D_Z(z) $</formula> and <formula id="72">$ D_M(m) $</formula> are the probability densities of <formula id="73">$ Z$</formula> and <formula id="74">$ M, $</formula> respectively.</para>
</simplesect>
<simplesect kind="par"><title></title><para>This convolution can also be written        <formula id="144">\[    F_{Y_{i}}(y) = Prob \,(Y_i &lt; y) =
    \int_{-\infty}^\infty\,\cdots\,\int_{-\infty}^{\infty} 
        D_{M_{k}}(m_k)\,dm_k\:
    \int_{-\infty}^{g(y,\vec{a},\vec{m})} D_Z(z)\,dz, \qquad
    g(y,\vec{a},\vec{m}) = \frac{y - \sum_k a_{i,k}m_k}
        {\sqrt{1-\sum_k a_{i,k}^2}}, \qquad \sum_k a_{i,k}^2 &lt; 1
\]</formula> In general, <formula id="145">$ F_{Y_{i}}(y) $</formula> needs to be computed numerically.</para>
</simplesect>
<simplesect kind="par"><title></title><para>The policy class template separates the copula function (the distributions involved) and the functionality (i.e. what the latent <linebreak/>
 model represents: a default probability, a recovery...). Since the <linebreak/>
 copula methods for the probabilities are to be called repeatedly from an integration or a MC simulation, virtual tables are avoided and template parameter mechnics is preferred.</para>
</simplesect>
<simplesect kind="par"><title></title><para>There is nothing at this level enforncing the requirement on the factor distributions to be of zero mean and unit variance. Thats the user responsibility and the model fails to behave correctly if it is not the case.</para>
</simplesect>
<simplesect kind="par"><title></title><para>Derived classes should implement a modelled magnitude (default time, etc) and will provide probability distributions and conditional values. They could also provide functionality for the parameter inversion problem, the (e.g.) time at which the modeled variable first takes a given value. This problem has solution/sense depending on the transfer function <formula id="146">$F_i(Y_i)$</formula> characteristics.</para>
</simplesect>
To make direct integration and simulation time efficient virtual functions have been avoided in accessing methods in the copula policy and in the sampling of the random factors </para>
    </detaileddescription>
    <inheritancegraph>
      <node id="5">
        <label>QuantLib::ConstantLossLatentmodel&lt; TCopulaPolicy &gt;</label>
        <link refid="class_quant_lib_1_1_constant_loss_latentmodel"/>
        <childnode refid="4" relation="public-inheritance">
        </childnode>
      </node>
      <node id="4">
        <label>QuantLib::DefaultLatentModel&lt; TCopulaPolicy &gt;</label>
        <link refid="class_quant_lib_1_1_default_latent_model"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>QuantLib::LatentModel&lt; copulaPolicyImpl &gt;</label>
        <link refid="class_quant_lib_1_1_latent_model"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3">
        <label>QuantLib::Observable</label>
        <link refid="class_quant_lib_1_1_observable"/>
      </node>
      <node id="2">
        <label>QuantLib::Observer</label>
        <link refid="class_quant_lib_1_1_observer"/>
      </node>
      <node id="6">
        <label>QuantLib::SpotRecoveryLatentModel&lt; TCopulaPolicy &gt;</label>
        <link refid="class_quant_lib_1_1_spot_recovery_latent_model"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="4">
        <label>QuantLib::Handle&lt; QuantLib::Quote &gt;</label>
        <link refid="class_quant_lib_1_1_handle"/>
      </node>
      <node id="1">
        <label>QuantLib::LatentModel&lt; copulaPolicyImpl &gt;</label>
        <link refid="class_quant_lib_1_1_latent_model"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
        <childnode refid="4" relation="usage">
          <edgelabel>cachedMktFactor_</edgelabel>
        </childnode>
      </node>
      <node id="3">
        <label>QuantLib::Observable</label>
        <link refid="class_quant_lib_1_1_observable"/>
      </node>
      <node id="2">
        <label>QuantLib::Observer</label>
        <link refid="class_quant_lib_1_1_observer"/>
      </node>
    </collaborationgraph>
    <location file="ql/experimental/math/latentmodel.hpp" line="278" column="5" bodyfile="ql/experimental/math/latentmodel.hpp" bodystart="280" bodyend="634"/>
    <listofallmembers>
      <member refid="class_quant_lib_1_1_latent_model_1a77b6963ac7d92d55caade265c40af9e4" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>allFactorCumulInverter</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1a68e201047207fd50ca0725a2cb7a21d4" prot="protected" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>cachedMktFactor_</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1ae56d8a54eabfb0d0216f472c727b65ac" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>copula</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1aa3dbc85525bd7e1dfbf3a41591cabe27" prot="protected" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>copula_</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1aad1fd370b3f36c3cf24b661d189fed01" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>copulaType</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1af159333d575c0b252de3c71371919dc2" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>cumulativeY</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1ae64724a9ecdc4cb7dadd555b019da10b" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>cumulativeZ</name></member>
      <member refid="class_quant_lib_1_1_observer_1acfbf794db3e7d5cfdea2cd517a195183" prot="public" virt="virtual"><scope>QuantLib::LatentModel</scope><name>deepUpdate</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1a9711849d61e8bc79608424661ac9dde2" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>density</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1a9058f44d45963e20631cf813f500ed50" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>factorWeights</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1a416b1acb0a0321ba7eac54c1bc1c494d" prot="protected" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>factorWeights_</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1ad630746a257d3e970ecf83cd47878cd3" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>idiosyncFctrs</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1a4f058b49788035828bbe2b3e78db9ebe" prot="protected" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>idiosyncFctrs_</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1a8f73847f26e632e54de23dc218e44875" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>integratedExpectedValue</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1a450b60907aff21aa12ef61c50206ec4b" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>integratedExpectedValueV</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1a89eb0c30269ba582f13776a19048c94b" prot="protected" virt="virtual"><scope>QuantLib::LatentModel</scope><name>integration</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1a10f1e843503876609d1cb14ac9b26c8e" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>inverseCumulativeDensity</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1a8f4c7a3b52e2a50a88b3a2e67cc1109b" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>inverseCumulativeY</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1a28355f257003546d33fda003452c820e" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>inverseCumulativeZ</name></member>
      <member refid="class_quant_lib_1_1_observer_1ad45fa6f7242ee763d17c714a3e8bb6d7" prot="public" virt="non-virtual" ambiguityscope="QuantLib::"><scope>QuantLib::LatentModel</scope><name>iterator</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1a2423b7437ca2ba9796e153bd9b9df050" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>LatentModel</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1a250ac646a6be88e253dc37c2620de9dd" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>LatentModel</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1a762ae56003287bdd2995e5a46a8c9f57" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>LatentModel</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1a4200b7490c6d6690d2ec1df95d4862ba" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>LatentModel</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1a9d3034be325054187dfafbd5f7ef1890" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>latentVariableCorrel</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1aede4740894962881f21e1522349eb287" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>latentVarValue</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1acd1daf4e28ce8ab5233065be60fd2896" prot="protected" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>nFactors_</name></member>
      <member refid="class_quant_lib_1_1_observable_1afb67478418efdb94382ac9d7ae904b94" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>notifyObservers</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1ad410d410b17c524efa114598a0455936" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>numFactors</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1a752c04c15550a49537c7eb0557bd6b16" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>numTotalFactors</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1a43e8cf454283157cab9a90b5aa261409" prot="protected" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>nVariables_</name></member>
      <member refid="class_quant_lib_1_1_observable_1ae0d19b21fab87a01f53586a6b5c15f85" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>Observable</name></member>
      <member refid="class_quant_lib_1_1_observable_1a942cf6a572bd95341433a6772c70cb29" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>Observable</name></member>
      <member refid="class_quant_lib_1_1_observable_1a6c35885ef344665ecdfac9b9f3a59c0e" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>Observable</name></member>
      <member refid="class_quant_lib_1_1_observer_1a246072080d37c0cd180013417251c70b" prot="public" virt="non-virtual" ambiguityscope="QuantLib::"><scope>QuantLib::LatentModel</scope><name>Observer</name></member>
      <member refid="class_quant_lib_1_1_observer_1ae6e892e237db5ffe7acbef54360ef0e3" prot="public" virt="non-virtual" ambiguityscope="QuantLib::"><scope>QuantLib::LatentModel</scope><name>Observer</name></member>
      <member refid="class_quant_lib_1_1_observer_1a40ad1a8bfb71e32b2916b370f3f9392c" prot="public" virt="non-virtual" ambiguityscope="QuantLib::"><scope>QuantLib::LatentModel</scope><name>operator=</name></member>
      <member refid="class_quant_lib_1_1_observable_1ad1e086da62f05b4bc5eafa698ef6fbc3" prot="public" virt="non-virtual" ambiguityscope="QuantLib::Observable::"><scope>QuantLib::LatentModel</scope><name>operator=</name></member>
      <member refid="class_quant_lib_1_1_observable_1ab45941c65068ab4c8d69a7d1a72beeb7" prot="public" virt="non-virtual" ambiguityscope="QuantLib::Observable::"><scope>QuantLib::LatentModel</scope><name>operator=</name></member>
      <member refid="class_quant_lib_1_1_observer_1a312bbe4a5386f10a1584f3477b3c2709" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>registerWith</name></member>
      <member refid="class_quant_lib_1_1_observer_1a338928c4fe626f9ccf0b98ceb318853a" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>registerWithObservables</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1a1dedcee7cecd341a0ed6131577b2f48e" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>size</name></member>
      <member refid="class_quant_lib_1_1_observer_1a297d13afa77b0e7e6deae3bab777180f" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>unregisterWith</name></member>
      <member refid="class_quant_lib_1_1_observer_1ab88925691aba7e7d96cc5188e94361ea" prot="public" virt="non-virtual"><scope>QuantLib::LatentModel</scope><name>unregisterWithAll</name></member>
      <member refid="class_quant_lib_1_1_latent_model_1a25404a7f39fe1422f6e4dd1fb9b67115" prot="public" virt="virtual"><scope>QuantLib::LatentModel</scope><name>update</name></member>
      <member refid="class_quant_lib_1_1_observable_1a32093a7038e9bd8d28e5d378eca9f4f7" prot="public" virt="virtual"><scope>QuantLib::LatentModel</scope><name>~Observable</name></member>
      <member refid="class_quant_lib_1_1_observer_1a6b5c15445bbe598d34871f5a5a3ed671" prot="public" virt="virtual"><scope>QuantLib::LatentModel</scope><name>~Observer</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
